{"version":3,"file":"chartjs-plugin-waterfall.min.js","sources":["../src/drawStepLines.js","../src/index.js"],"sourcesContent":["import groupBy from 'lodash.groupby';\n\nconst drawOnCanvas = (context, options, firstDataPoints, secondDataPoints, useFakeBase) => {\n  const firstStackBase = useFakeBase ? firstDataPoints.stackFakeBase : firstDataPoints.stackBase;\n  const secondStackBase = useFakeBase ? secondDataPoints.stackFakeBase : secondDataPoints.stackBase;\n\n  // Gradient from top of second box to bottom of both boxes\n  const gradient = context.createLinearGradient(\n    0,\n    secondDataPoints.stackTopYPos,\n    0,\n    secondStackBase,\n  );\n\n  gradient.addColorStop(options.startColorStop, options.startColor);\n  gradient.addColorStop(options.endColorStop, options.endColor);\n\n  context.fillStyle = gradient;\n\n  context.beginPath();\n  // top right of first box\n  context.lineTo(firstDataPoints.stackRightXPos, firstDataPoints.stackTopYPos);\n  // top left of second box\n  context.lineTo(secondDataPoints.stackLeftXPos, secondDataPoints.stackTopYPos);\n  // bottom left of second box\n  context.lineTo(secondDataPoints.stackLeftXPos, secondStackBase);\n  // bottom right of first box\n  context.lineTo(firstDataPoints.stackRightXPos, firstStackBase);\n  context.fill();\n};\n\nexport default (chart) => {\n  const context = chart.ctx;\n  const datasets = chart.data.datasets;\n  const options = chart.options.plugins.waterFallPlugin.stepLines;\n  const stackedDatasets = groupBy(datasets, 'stack');\n  const newDatasets = [];\n  const getModel = (dataset) => {\n    const firstKey = Object.keys(dataset._meta)[0];\n\n    return dataset._meta[firstKey].data[0]._model;\n  };\n\n  const getNewDataPoints = (existingDataset) => {\n    const newDataPoints = [];\n    let stackBase = null;\n\n    existingDataset.forEach((dataset, i) => {\n      const model = getModel(dataset);\n\n      if (i === 0) {\n        stackBase = model.base;\n      }\n\n      newDataPoints.push({\n        stackRightXPos: model.x + (model.width / 2),\n        stackLeftXPos: model.x - (model.width / 2),\n        stackTopYPos: model.y,\n        stackBase,\n      });\n    });\n\n    return newDataPoints;\n  };\n\n  Object.keys(stackedDatasets).forEach((key) => {\n    const currentStackedDataset = stackedDatasets[key];\n    const realStackedDataset = currentStackedDataset.filter(x => !x.dummyStack);\n\n    newDatasets.push({\n      allDataPoints: getNewDataPoints(currentStackedDataset),\n      allRealDataPoints: getNewDataPoints(realStackedDataset),\n    });\n  });\n\n  const getFirstDataPointValues = dataset => ({\n    stackRightXPos: dataset.allRealDataPoints[0].stackRightXPos,\n    stackLeftXPos: dataset.allRealDataPoints[0].stackLeftXPos,\n    stackTopYPos: dataset.allRealDataPoints[dataset.allRealDataPoints.length - 1].stackTopYPos,\n    stackBase: dataset.allRealDataPoints[0].stackBase,\n    stackFakeBase: dataset.allDataPoints[0].stackBase,\n  });\n\n  const stacksYPosOrBaseAreEqual = (firstDataPoints, secondDataPoints) =>\n    (firstDataPoints.stackTopYPos === secondDataPoints.stackTopYPos &&\n    firstDataPoints.stackFakeBase === secondDataPoints.stackFakeBase);\n\n  for (let i = 0; i < newDatasets.length; i += 1) {\n    const firstDataSet = newDatasets[i];\n\n    if (i !== newDatasets.length - 1) {\n      const secondDataSet = newDatasets[i + 1];\n      const firstDataPoints = getFirstDataPointValues(firstDataSet);\n      const secondDataPoints = getFirstDataPointValues(secondDataSet);\n\n      // Needed to convert step lines to look like bars when we have floating stacks\n      if (firstDataPoints.stackTopYPos === secondDataPoints.stackBase) {\n        secondDataPoints.stackTopYPos = secondDataPoints.stackBase;\n      } else if (firstDataPoints.stackBase === secondDataPoints.stackTopYPos) {\n        firstDataPoints.stackTopYPos = firstDataPoints.stackBase;\n      }\n\n      if (options.diagonalStepLines ||\n          stacksYPosOrBaseAreEqual(firstDataPoints, secondDataPoints)) {\n        drawOnCanvas(context, options, firstDataPoints, secondDataPoints, true);\n      }\n\n      if (Array.isArray(options.diagonalStepLines)) {\n        options.diagonalStepLines.forEach((dataPointArray) => {\n          const firstDataPointIndex = dataPointArray[0];\n          const secondDataPointIndex = dataPointArray[1];\n          const firstDiagonalDataPoints = firstDataSet.allRealDataPoints[firstDataPointIndex];\n          const secondDiagonalDataPoints = secondDataSet.allRealDataPoints[secondDataPointIndex];\n\n          if (firstDiagonalDataPoints && secondDiagonalDataPoints) {\n            drawOnCanvas(context, options, firstDiagonalDataPoints, secondDiagonalDataPoints);\n          }\n        });\n      }\n    }\n  }\n};\n","import merge from 'lodash.merge';\n\nimport drawStepLines from './drawStepLines';\n\nconst defaultOptions = {\n  waterFallPlugin: {\n    stepLines: {\n      enabled: true,\n      startColorStop: 0,\n      endColorStop: 0.6,\n      startColor: 'rgba(0, 0, 0, 0.55)', // opaque\n      endColor: 'rgba(0, 0, 0, 0)', // transparent\n      diagonalStepLines: true,\n    },\n  },\n};\n\nconst status = {};\n\nconst filterDummyStacks = (legendItem, chartData) => {\n  const currentDataset = chartData.datasets[legendItem.datasetIndex];\n\n  return !currentDataset.dummyStack;\n};\n\nconst waterFallPlugin = {\n  beforeInit: (chart) => {\n    status[chart.id] = {\n      readyToDrawStepLines: false,\n    };\n  },\n  afterInit: (chart) => {\n    chart.options.plugins = merge({}, defaultOptions, chart.options.plugins);\n    chart.options.tooltips.filter = filterDummyStacks;\n    chart.options.legend.labels.filter = filterDummyStacks;\n\n    // Can't override onComplete function because it gets overwridden if user using React\n    setTimeout(() => {\n      status[chart.id].readyToDrawStepLines = true;\n\n      drawStepLines(chart);\n    }, chart.options.animation.duration);\n\n\n    chart.data.datasets.forEach((dataset, i) => {\n      // Each dataset must have a unique label so we set the dummy stacks to have dummy labels\n      if (dataset.dummyStack) {\n        dataset.label = `dummyStack_${i}`;\n        dataset.backgroundColor = 'rgba(0, 0, 0, 0)';\n      }\n    });\n  },\n  afterDraw: (chart) => {\n    const options = chart.options.plugins.waterFallPlugin;\n\n    if (options.stepLines.enabled &&\n        status[chart.id].readyToDrawStepLines) {\n      drawStepLines(chart);\n    }\n  },\n};\n\nexport default waterFallPlugin;\n"],"names":["drawOnCanvas","context","options","firstDataPoints","secondDataPoints","useFakeBase","firstStackBase","stackFakeBase","stackBase","secondStackBase","gradient","createLinearGradient","stackTopYPos","addColorStop","startColorStop","startColor","endColorStop","endColor","fillStyle","beginPath","lineTo","stackRightXPos","stackLeftXPos","fill","chart","ctx","datasets","data","plugins","waterFallPlugin","stepLines","stackedDatasets","groupBy","newDatasets","getModel","dataset","firstKey","Object","keys","_meta","_model","getNewDataPoints","existingDataset","newDataPoints","forEach","i","model","base","push","x","width","y","key","currentStackedDataset","realStackedDataset","filter","dummyStack","getFirstDataPointValues","allRealDataPoints","length","allDataPoints","stacksYPosOrBaseAreEqual","firstDataSet","secondDataSet","diagonalStepLines","Array","isArray","dataPointArray","firstDataPointIndex","secondDataPointIndex","firstDiagonalDataPoints","secondDiagonalDataPoints","defaultOptions","status","filterDummyStacks","legendItem","chartData","datasetIndex","id","merge","tooltips","legend","labels","readyToDrawStepLines","animation","duration","label","backgroundColor","enabled"],"mappings":"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"}